/**
 * Definition for Directed graph.
 * struct DirectedGraphNode {
 *     int label;
 *     vector<DirectedGraphNode *> neighbors;
 *     DirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
    /**
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {
        // write your code here
        queue <DirectedGraphNode *> Q;
        vector <DirectedGraphNode *> V;
        unordered_map<DirectedGraphNode *, int> inCount = inDegree(graph);
        //unordered_set<DirectedGraphNode *> S;
        for(auto& n : graph) {
            if(inCount[n] == 0) {
                Q.push(n);        
            }
        }    
            while (!Q.empty()) {
                DirectedGraphNode * head = Q.front();
                Q.pop();
                V.push_back(head);
                //S.insert(head);
                for (auto& n : head->neighbors) {
                    inCount[n] = inCount[n] - 1;
                    if(inCount[n] == 0) {
                        Q.push(n);
                    }
                }
            }
        if(V.size() == graph.size()) {    
            return V;
        }

        vector <DirectedGraphNode *> NullV;
        return NullV; 
    }
    
    unordered_map<DirectedGraphNode*, int> inDegree(vector<DirectedGraphNode*> graph) {
        unordered_map<DirectedGraphNode*, int> result;
        for(auto& n : graph) {
            result.insert({n, 0});
        }
        for(auto& n : graph) {
            for(auto& m : n->neighbors){
                result[m] = result[m] + 1;
            }
        }
        return result;
        
    }
    
};



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    """
    def topSort(self, graph):
        # write your code here
        from queue import Queue
        q = Queue()
        visit = {}
        res = []
        tmp = self.inDegree(graph)
        # print(tmp)
        for i, j in tmp.items():
            if j == 0:
                q.put(i)
                visit[i] = True
                # print(q.qsize())
        while not q.empty():
            node = q.get()
            for i in node.neighbors:
                if i in visit:
                    continue
                tmp[i] -= 1
                if tmp[i] == 0:
                    q.put(i)
                    visit[i] = True
        return visit.keys()
        
    def inDegree(self,graph):
        tmp = {n:0 for n in graph}
        for i in graph:
            for j in i.neighbors:
                tmp[j] += 1
        return tmp
            
            
        
