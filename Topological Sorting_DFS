LintCode-Logo
Home
Algorithms
AI
CATnew
VIP
Language
avatarswb441200165
Back
127. Topological Sorting
This is the problem you have done. Do you remember how to solve it?
Description
中文
English
Given an directed graph, a topological order of the graph nodes is defined as follow:

For each directed edge A -> B in graph, A must before B in the order list.
The first node in the order can be any node in the graph with no nodes direct to it.
Find any topological order for the given graph.

You can assume that there is at least one topological order in the graph.

Have you met this question in a real interview?  
Clarification
Learn more about representation of graphs

Example
For graph as follow:

picture

The topological order can be:

[0, 1, 2, 3, 4, 5]
[0, 2, 3, 1, 5, 4]
...
Challenge
Can you do it in both BFS and DFS?

Related Problems
DifficultyMedium
Total Accepted25423
Total Submitted68485
Accepted Rate37%
 Show Tags
Leaderboard - Python3

shuairuiyao
996ms

sincewhenUCLA
1026ms

wufan
1114ms

kxfeng
1117ms

ze04
1118ms
Note
""" Definition for a Directed graph node class DirectedGraphNode: def __init__(self, x): self.label = x self.neighbors = [] """ class Solution: """ @param: graph: A list of Directed graph node @return: Any topological order for the given graph. """ def topSort(self, graph): if not graph or len(graph) == 0: return [] ans = [] from collections import deque, defaultdict q = deque() ind = defaultdict(int) for node in graph: if node not in ind: ind[node] = 0 for neigh in node.neighbors: ind[neigh] += 1 for k, v in ind.items(): if v == 0: q.append(k) while q: node = q.popleft() ans.append(node) for neigh in node.neighbors: ind[neigh] -= 1 if ind[neigh] == 0: q.append(neigh) return ans
avatarandy15
Created at 18 hours ago
def __init__(self): self.inDegree = {} def topSort(self, graph): # write your code here if not graph: return [] result = [] self.calcInDegree(graph) Q = [] for k, v in self.inDegree.items(): if self.inDegree[k] == 0: Q.append(k) while Q: u = Q.pop(0) result.append(u) for v in u.neighbors: self.inDegree[v] -= 1 if self.inDegree[v] == 0: Q.append(v) return result def calcInDegree(self, graph): # count in-degrees for all nodes for node in graph: if node not in self.inDegree: self.inDegree[node] = 0 for neighbor in node.neighbors: if neighbor in self.inDegree: self.inDegree[neighbor] += 1 else: self.inDegree[neighbor] = 1
avatarbryan07Bronze IV
Created at 2 days ago
1. Count all 0-indegree Nodes 2. put all 0-indegree Nodes in queue 3. poll every nodes and neighbor nodes indegree - 1 4. when indegree = 0, put node in queue
avatarJerryLintCode
Created at 4 days ago
Discuss
leon23 · Last reply by · leon23 · 9 months ago
  
127. Topological Sorting
中文English
Given an directed graph, a topological order of the graph nodes is defined as follow:

For each directed edge A -> B in graph, A must before B in the order list.
The first node in the order can be any node in the graph with no nodes direct to it.
Find any topological order for the given graph.

Example
For graph as follow:

picture

The topological order can be:

[0, 1, 2, 3, 4, 5]
[0, 2, 3, 1, 5, 4]
...
Challenge
Can you do it in both BFS and DFS?

Clarification
Learn more about representation of graphs

Notice
You can assume that there is at least one topological order in the graph.

{0,1,2,3,4#1,3,4#2,1,4#3,4#4}


/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/**
 * Definition for Directed graph.
 * struct DirectedGraphNode {
 *     int label;
 *     vector<DirectedGraphNode *> neighbors;
 *     DirectedGraphNode(int x) : label(x) {};
 * };
 */
class Solution {
public:
    /**
     * @param graph: A list of Directed graph node
     * @return: Any topological order for the given graph.
     */
    vector<DirectedGraphNode*> topSort(vector<DirectedGraphNode*> graph) {
        // write your code here
        queue <DirectedGraphNode *> Q;
        vector <DirectedGraphNode *> V;
        unordered_map<DirectedGraphNode *, int> inCount = inDegree(graph);
        //unordered_set<DirectedGraphNode *> S;
        for(auto& n : graph) {
            if(inCount[n] == 0) {
                Q.push(n);        
            }
        }    
            while (!Q.empty()) {
                DirectedGraphNode * head = Q.front();
                Q.pop();
                V.push_back(head);
                //S.insert(head);
                for (auto& n : head->neighbors) {
                    inCount[n] = inCount[n] - 1;
                    if(inCount[n] == 0) {
                        Q.push(n);
                    }
                }
            }
        if(V.size() == graph.size()) {    
            return V;
        }

        vector <DirectedGraphNode *> NullV;
        return NullV; 
    }
    
    unordered_map<DirectedGraphNode*, int> inDegree(vector<DirectedGraphNode*> graph) {
        unordered_map<DirectedGraphNode*, int> result;
        for(auto& n : graph) {
            result.insert({n, 0});
        }
        for(auto& n : graph) {
            for(auto& m : n->neighbors){
                result[m] = result[m] + 1;
            }
        }
        return result;
        
    }
    
};



/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    """
    def topSort(self, graph):
        # write your code here
        from queue import Queue
        q = Queue()
        visit = {}
        res = []
        tmp = self.inDegree(graph)
        # print(tmp)
        for i, j in tmp.items():
            if j == 0:
                q.put(i)
                visit[i] = True
                # print(q.qsize())
        while not q.empty():
            node = q.get()
            for i in node.neighbors:
                if i in visit:
                    continue
                tmp[i] -= 1
                if tmp[i] == 0:
                    q.put(i)
                    visit[i] = True
        return visit.keys()
        
    def inDegree(self,graph):
        tmp = {n:0 for n in graph}
        for i in graph:
            for j in i.neighbors:
                tmp[j] += 1
        return tmp
            
         
///////////////////////////////////////////////remove visit dictionary since inDegree can make sure there is no loop/////////////////
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    """
    def topSort(self, graph):
        # write your code here
        from queue import Queue
        q = Queue()
        # visit = {}
        res = []
        tmp = self.inDegree(graph)
        # print(tmp)
        for i, j in tmp.items():
            if j == 0:
                q.put(i)
                # visit[i] = True
                # print(q.qsize())
        while not q.empty():
            node = q.get()
            res.append(node)
            for i in node.neighbors:
                # if i in visit:
                #     continue
                tmp[i] -= 1
                if tmp[i] == 0:
                    q.put(i)
                    # visit[i] = True
        return res
        
    def inDegree(self,graph):
        tmp = {n:0 for n in graph}
        for i in graph:
            for j in i.neighbors:
                tmp[j] += 1
        return tmp
            
            
////////////////////////////////////////////////////////////////There is some issue////////////////////////////////////////////////////////////////////\
"""
Definition for a Directed graph node
class DirectedGraphNode:
    def __init__(self, x):
        self.label = x
        self.neighbors = []
"""


class Solution:
    """
    @param: graph: A list of Directed graph node
    @return: Any topological order for the given graph.
    """
    def topSort(self, graph):
        # write your code here
        if not graph:
            return []
        indegreeMap = self.inDegree(graph)
        from queue import Queue
        q = Queue()
        res = set()
        for key, value in indegreeMap.items():
            if value == 0:
                q.put(key)
        while not q.empty():
            tmp = q.get()
            res.add(tmp)
            for i in tmp.neighbors:
                if indegreeMap[i] > 0:
                    indegreeMap[i] -= 1
                    if indegreeMap[i] == 0:
                        q.put(i)
        if len(res) == len(indegreeMap):
            return res
        return []
        
    def inDegree(self, graph):
        indegreeMap = {x: 0 for x in graph}
        for i in graph:
            for j in i.neighbors:
                indegreeMap[j] += 1
        return indegreeMap
        
