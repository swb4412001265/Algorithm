433. Number of Islands
中文English
Given a boolean 2D matrix, 0 is represented as the sea, 1 is represented as the island. If two 1 is adjacent, we consider them in the same island. We only consider up/down/left/right adjacent.

Find the number of islands.

Example
Example 1:

Input:
[
  [1,1,0,0,0],
  [0,1,0,0,1],
  [0,0,0,1,1],
  [0,0,0,0,0],
  [0,0,0,0,1]
]
Output:
3
Example 2:

Input:
[
  [1,1]
]
Output:
1
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
class Solution {
public:
    /**
     * @param grid a boolean 2D matrix
     * @return an integer
     */
    void dfs(vector<vector<bool>> &grid, int x, int y) {
        if (x < 0 || x >= grid.size()) return;
        if (y < 0 || y >= grid[0].size()) return;
        if (grid[x][y] != true) return;
        grid[x][y] = false;
        dfs(grid, x + 1, y);
        dfs(grid, x - 1, y);
        dfs(grid, x, y + 1);
        dfs(grid, x, y - 1);
    }
    int numIslands(vector<vector<bool>>& grid) {
        // Write your code here
        if (grid.empty() || grid[0].empty()) return 0;
        int N = grid.size(), M = grid[0].size();
        int cnt = 0;
        for (int i = 0; i < N; ++i) {
            for (int j = 0; j < M; ++j) {
                if (grid[i][j] == true) {
                    dfs(grid, i, j);
                    ++cnt;
                }
            }
        }
        return cnt;
    }
};

/////////////////////////////////////////////////////////Need More Debug/////////////////////////////////////////////////////////////////////
class Solution {
public:
    /**
     * @param grid a boolean 2D matrix
     * @return an integer
     */
    int numIslands(vector<vector<bool>>& grid) {
        // Write your code here
        int m = grid.size();
        int n = grid[0].size();
        if(m == 0 || n == 0) {
            return 0;
        }
        int count = 0;
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(grid[i][j] == true) {
                    BFS(grid, i ,j);
                    count++;
                }
            }
        }
        return count;
    }
    void BFS(vector<vector<bool>>& grid, int i, int j) {
        grid[i][j] = false;
        int x[4] = {0,-1,0,1};
        int y[4] = {-1,0,1,0};
        for(int z = 0; z < 4; ++z) {
            i = x[z] + i;
            j = y[z] + j;
            if(i < 0 || j < 0 || i > grid.size() - 1|| j > grid[0].size() - 1) {
                continue;
            }
            if(grid[i][j] == true) {
                grid[i][j] = false;
                BFS(grid, i, j);
            }
        }
        //return;
    }
    
};


///////////////////////////////////////////////////////////Python//////////////////////////////////////////////////////////////////

class Solution:
    # @param {boolean[][]} grid a boolean 2D matrix
    # @return {int} an integer
    def numIslands(self, grid):
        # Write your code here
        result = 0
        if len(grid) is 0:
            return result
        if grid is None:
            return result
        row = len(grid)
        column = len(grid[0])
        for i in range(row):
            for j in range(column):
                if grid[i][j] is 1:
                    self.DFS(grid, i, j)
                    result += 1
        return result
        
    def DFS(self, grid, x, y):
        grid[x][y] = 0
        q= Queue()
        a = [-1, 0, 0, 1]
        b = [0, 1, -1, 0]
        q.put(x, y)
        while q.empty() is False:
            new_row, new_column = q.get()
            for i in range(4):
                tmp_row = new_row + a[i]
                tmp_column = new_column + b[i]
                if tmp_row < 0 or tmp_row > len(grid) - 1 or tmp_column < 0 \
                or tmp_column > len(grid[0]) - 1:
                    continue
                if grid[tmp_row][tmp_column] is 1:
                    grid[tmp_row][tmp_column] = 0
                    q.put(tmp_row, tmp_column)
                    
                    
                    
///////////////////////////////////////////////Python with list + tuple/////////////////////////////////////////////////////////////

class Solution:
    # @param {boolean[][]} grid a boolean 2D matrix
    # @return {int} an integer
    def numIslands(self, grid):
        # Write your code here
        result = 0
        if len(grid) is 0:
            return result
        if grid is None:
            return result
        row = len(grid)
        column = len(grid[0])
        for i in range(row):
            for j in range(column):
                if grid[i][j] is True:
                    self.DFS(grid, i, j)
                    result += 1
        return result
        
    def DFS(self, grid, x, y):
        grid[x][y] = False
        q= [(x,y)]
        a = [-1, 0, 0, 1]
        b = [0, 1, -1, 0]
        while len(q) > 0:
            (new_row, new_column) = q.pop(0)
            for i in range(4):
                tmp_row = new_row + a[i]
                tmp_column = new_column + b[i]
                if tmp_row < 0 or tmp_row > len(grid) - 1 or tmp_column < 0 \
                or tmp_column > len(grid[0]) - 1:
                    continue
                if grid[tmp_row][tmp_column] is True:
                    grid[tmp_row][tmp_column] = False
                    q.append((tmp_row, tmp_column))
